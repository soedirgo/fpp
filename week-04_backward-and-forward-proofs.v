(* week-04_backward-and-forward-proofs.v *)
(* YSC3236 2020-2021, Sem1 *)
(* Olivier Danvy <danvy@yale-nus.edu.sg> *)
(* Version of 05 Sep 2020 *)

(* ********** *)

(* Your name: Koo Zhengqun
   Your e-mail address: zhengqun.koo@u.nus.edu
   Your student number: A0164207L
 *)

(* Your name: Bobbie Soedirgo
   Your e-mail address: sram-b@comp.nus.edu.sg
   Your student number: A0181001A
 *)

(* Your name: Kuan Wei Heng
   Your e-mail address: kuanwh@u.nus.edu
   Your student number: A0121712X
 *)

(**
 %\title{Functional Programming in Coq}%
 %\author{Bobbie Soedirgo, Koo Zhengqun, Kuan Wei Heng}%
 %\date{\today}%
 %\maketitle%
 %\tableofcontents%
 %\newpage%
 *)

(** * Introduction
    Roughly speaking,
    - Backward proofs are a chain of [apply] tactics that apply hypotheses to the goal, until the goal exactly matches one of the hypotheses.
    - Forward proofs are a chain of [apply] tactics that apply hypotheses to other hypotheses, binding the resulting hypotheses to new names, until the goal matches exactly the result of a tactic applied to a subset of the hypotheses.

    In contrasting backward/forward proofs, this assignment gets students to consider the information flow in a proof. Students can think of a proof as a bunch of OCaml <<let>>-<<in>> statements, whereby the hypotheses generated by previous proof steps continue to exist for the rest of the proof (unless the hypotheses are consumed).

    Then when the student needs to prove subgoals (as a result of [split] on a conjunction in the goal, or of [destruct] on a disjunction in the hypotheses), the set of hypotheses just before entering each subgoal is "saved": Even though the student consumes some hypotheses in a subgoal, when the student goes to prove the other subgoal, the "saved" hypotheses are "restored": Consumed hypotheses "re-appear" in the other subgoal.

    A duplication of hypotheses means the proof is classical instead of linear.

    We shall also see that the dual of duplication can occur: A discarding of hypotheses.
 *)

(* ***********)

(* Learning goals:

   * using apply among the assumptions

   * using assert to declare a new assumption

   * using split to prove conjunctions
*)

(* ***********)

(* begin hide *)
Proposition identity :
  forall A : Prop,
    A -> A.
Proof.
  intros A H_A.
  apply H_A.
Qed.

Proposition modus_ponens :
  forall A B : Prop,
    A -> (A -> B) -> B.
Proof.
  intros A B H_A H_A_implies_B.
  (* backward, from the goal: *)
  apply H_A_implies_B.
  apply H_A.

  Restart.

  intros A B H_A H_A_implies_B.
  (* forward, from the initial hypothesis: *)
  apply H_A_implies_B in H_A.
  exact H_A.

  Restart.

  intros A B H_A H_A_implies_B.
  (* forward, keeping in control of the naming: *)
  assert (H_B := H_A_implies_B H_A).
  exact H_B.
Qed.

Proposition modus_ponens_and_more :
  forall A B C : Prop,
    A -> (A -> B) -> (B -> C) -> C.
Proof.
  intros A B C H_A H_A_implies_B H_B_implies_C.
  (* backward, from the goal: *)
  apply H_B_implies_C.
  apply H_A_implies_B.
  apply H_A.

  Restart.

  intros A B C H_A H_A_implies_B H_B_implies_C.
  (* forward, from the initial hypothesis: *)
  Check (H_A_implies_B H_A).
  assert (H_B := H_A_implies_B H_A).
  Check (H_B_implies_C H_B).
  exact (H_B_implies_C H_B).
Qed.

Proposition modus_ponens_and_even_more :
  forall A B C D : Prop,
    A -> (A -> B) -> (B -> C) -> (C -> D) -> D.
Proof.
  intros A B C D H_A H_A_implies_B H_B_implies_C H_C_implies_D.
  (* backward, from the goal: *)
  apply H_C_implies_D.
  apply H_B_implies_C.
  apply H_A_implies_B.
  apply H_A.

  Restart.

  intros A B C D H_A H_A_implies_B H_B_implies_C H_C_implies_D.
  (* forward, from the initial hypothesis: *)
  assert (H_B := H_A_implies_B H_A).
  assert (H_C := H_B_implies_C H_B).
  Check (H_C_implies_D H_C).
  exact (H_C_implies_D H_C).
Qed.
(* end hide *)

(* ********** *)

(** * Exercise 9 *)

(* Prove foo:

   (1) backward, in a goal-directed way

   (2) forward, from the assumptions
*)

Proposition foo :
  forall P Q R1 R2 : Prop,
    P -> (P -> Q) -> (Q -> R1) /\ (Q -> R2) -> R1 /\ R2.
Proof.
  intros P Q R1 R2.
  intros H_P H_P_implies_Q H_Q_implies_R1_and_Q_implies_R2.
  (** Backward, from the goal:
      Here is a strictly backward proof, where we act on the goal as the first proof step. Because the goal is a conjunction, we must split. Because in each subgoal, [H_Q_implies_R1_and_Q_implies_R2] occurs, therefore we need to repeat the [destruct] on that hypothesis in each subgoal.

      Since the first proof step is to act on [R1 /\ R2], the backward proof corresponds to using [split] as early as possible.
   *)

  split.
  - destruct H_Q_implies_R1_and_Q_implies_R2 as [H_Q_implies_R1 H_Q_implies_R2].
    apply H_Q_implies_R1.
    apply H_P_implies_Q.
    exact H_P.
  (** The proof for the other case is symmetric.
   *)

  - destruct H_Q_implies_R1_and_Q_implies_R2 as [H_Q_implies_R1 H_Q_implies_R2].
    apply H_Q_implies_R2.
    apply H_P_implies_Q.
    exact H_P.
  Show Proof.
  (** The term corresponding to this proof is:
      <<
(fun (P Q R1 R2 : Prop) (H_P : P) (H_P_implies_Q : P -> Q)
   (H_Q_implies_R1_and_Q_implies_R2 : (Q -> R1) /\ (Q -> R2)) =>
 conj
   match H_Q_implies_R1_and_Q_implies_R2 with
   | conj H_Q_implies_R1 _ => H_Q_implies_R1 (H_P_implies_Q H_P)
   end
   match H_Q_implies_R1_and_Q_implies_R2 with
   | conj _ H_Q_implies_R2 => H_Q_implies_R2 (H_P_implies_Q H_P)
   end)
      >>

      Note the repeated occurences of [(H_P_implies_Q H_P)].

      Because our first proof step was to [split], the <<conj>> term appears first. This means the construction of our term first begins from each of the conjuncts.
   *)

  Restart.

  intros P Q R1 R2.
  intros H_P H_P_implies_Q H_Q_implies_R1_and_Q_implies_R2.
  (** Here is an alternative "backward" proof (not actually backward, because the first proof step does not act on the goal) that forecasts that we will need to destruct [H_Q_implies_R1_and_Q_implies_R2], because the goal is a conjunction, so we need two implications that each correspond to one of the conjuncts.
   *)

  destruct H_Q_implies_R1_and_Q_implies_R2 as [H_Q_implies_R1 H_Q_implies_R2].
  split.
  - apply H_Q_implies_R1.
    apply H_P_implies_Q.
    exact H_P.
  (** The proof for the other case is symmetric.
   *)

  - apply H_Q_implies_R2.
    apply H_P_implies_Q.
    exact H_P.
  Show Proof.
 (** The term corresponding to this proof is:
      <<
(fun (P Q R1 R2 : Prop) (H_P : P) (H_P_implies_Q : P -> Q)
   (H_Q_implies_R1_and_Q_implies_R2 : (Q -> R1) /\ (Q -> R2)) =>
 match H_Q_implies_R1_and_Q_implies_R2 with
 | conj H_Q_implies_R1 H_Q_implies_R2 =>
     conj (H_Q_implies_R1 (H_P_implies_Q H_P)) (H_Q_implies_R2 (H_P_implies_Q H_P))
 end)
      >>

      Note the repeated occurences of [(H_P_implies_Q H_P)].

      The term corresponding to this proof differs from the term corresponding to the previous proof, in that the <<conj>> corresponding to the [split] is within the <<match>>-case corresponding to the [destruct]. This allows both conjuncts of the <<conj>> to refer to both hypotheses that come from the [destruct]ion.

      There is no underscore in the pattern match, so there are no discarded hypotheses. In contrast, the term corresponding to the previous proof ignores (discards) one of the uneeded hypotheses when it is constructing each of its conjuncts.
   *)

  Restart.

  intros P Q R1 R2.
  intros H_P H_P_implies_Q H_Q_implies_R1_and_Q_implies_R2.
  (** Forward, from the initial hypothesis:
      Since [P] is the only atomic proposition we have, we must apply it to some other hypothesis.

      Since one of the last proof steps is to prove [R1 /\ R2], the forward proof corresponds to using [split] as late as possible.
   *)

  assert (H_Q := H_P_implies_Q H_P).
  (** Here, we realize that we cannot apply to [H_Q] to [H_Q_implies_R1_and_Q_implies_R2] without destructing [H_Q_implies_R1_and_Q_implies_R2]. So we destruct.
   *)

  destruct H_Q_implies_R1_and_Q_implies_R2 as [H_Q_implies_R1 H_Q_implies_R2].
  assert (H_R1 := H_Q_implies_R1 H_Q).
  assert (H_R2 := H_Q_implies_R2 H_Q).
  split.
  - exact H_R1.
  - exact H_R2.
  Show Proof.
  (** The term corresponding to this proof is:
      <<
(fun (P Q R1 R2 : Prop) (H_P : P) (H_P_implies_Q : P -> Q)
   (H_Q_implies_R1_and_Q_implies_R2 : (Q -> R1) /\ (Q -> R2)) =>
 let H_Q : Q := H_P_implies_Q H_P in
 match H_Q_implies_R1_and_Q_implies_R2 with
 | conj H_Q_implies_R1 H_Q_implies_R2 =>
     let H_R1 : R1 := H_Q_implies_R1 H_Q in let H_R2 : R2 := H_Q_implies_R2 H_Q in conj H_R1 H_R2
 end)
      >>

      Note the lack of repeated occurences of [(H_P_implies_Q H_P)] - these have been replaced by [H_Q].

      Also note: like the alternative backward proof, the pattern match does not discard any hypotheses. 
   *)

Qed.

(* ********** *)

(** * Exercise 10 *)

(* Prove bar:

   (1) by using the split tactic as early as possible 

   (2) by using the split tactic as late as possible 
*)

Proposition bar :
  forall P1 P2 Q R1 R2 T1 T2 : Prop,
    P1 -> (P1 -> P2) -> (P2 -> Q) -> (Q -> R1) -> (R1 -> T1) -> (Q -> R2) -> (R2 -> T2) -> T1 /\ T2.
Proof.
  intros P1 P2 Q R1 R2 T1 T2.
  intros H_P1 H_P1_implies_P2 H_P2_implies_Q H_Q_implies_R1 H_R1_implies_T1 H_Q_implies_R2 H_R2_implies_T2.

  (** Here, use the split tactic as early as possible.

      As hinted in Exercise 9, doing a backward proof requires us to immediately split, because none of the hypotheses is applicable to our goal (In contrast to Exercise 9, here Exercise 10 does not allow us to [destruct]).

      But the converse is not true: using a split tactic as early as possible does not require us to do a completely backward proof, because after each proof step, the remaining proof can be proven in a forward or backward way.

      Concretely, after [split], the first subgoal's <<*goals*>> buffer degenerates to a form similar to [modus_ponens_and_even_more], but instead of a chain of 3 implication hypotheses, here we have a chain of 4 implication hypotheses from [T1] to [P1]:
      <<
  P1, P2, Q, R1, R2, T1, T2 : Prop
  H_P1 : P1
  H_P1_implies_P2 : P1 -> P2
  H_P2_implies_Q : P2 -> Q
  H_Q_implies_R1 : Q -> R1
  H_R1_implies_T1 : R1 -> T1
  H_Q_implies_R2 : Q -> R2
  H_R2_implies_T2 : R2 -> T2
  ============================
  T1
      >>

      The second subgoal's <<*goals*>> buffer degenerates to a similar form.

      Therefore like [modus_ponens_and_even_more], we can apply either a forward or backward proof in each subgoal.

      We choose to do a backward proof in each subgoal, since then we don't have to bind new hypotheses to names.
   *)

  split.
  - apply H_R1_implies_T1.
    apply H_Q_implies_R1.
    apply H_P2_implies_Q.
    apply H_P1_implies_P2.
    exact H_P1.
  - apply H_R2_implies_T2.
    apply H_Q_implies_R2.
    apply H_P2_implies_Q.
    apply H_P1_implies_P2.
    exact H_P1.
  Show Proof.
  (** The term corresponding to this proof is:
      <<
(fun (P1 P2 Q R1 R2 T1 T2 : Prop) (H_P1 : P1) (H_P1_implies_P2 : P1 -> P2) (H_P2_implies_Q : P2 -> Q)
   (H_Q_implies_R1 : Q -> R1) (H_R1_implies_T1 : R1 -> T1) (H_Q_implies_R2 : Q -> R2)
   (H_R2_implies_T2 : R2 -> T2) =>
 conj (H_R1_implies_T1 (H_Q_implies_R1 (H_P2_implies_Q (H_P1_implies_P2 H_P1))))
   (H_R2_implies_T2 (H_Q_implies_R2 (H_P2_implies_Q (H_P1_implies_P2 H_P1)))))
      >>

      Note the repeated occurences of [H_P2_implies_Q (H_P1_implies_P2 H_P1)].

      Compared to using [split] as early as possible in Exercise 9, the repeated occurences now consist of two hypotheses applied to another hypothesis. This corresponds to the chain of implications until the point of divergence of [bar] in Exercise 10 having length 2 instead of 1 of [foo] in Exercise 9. Drawn in a diagram with no defined semantics (purely for intuition):

      The chain <<P -> Q>> has length 1 in [foo]:
      <<
                |-> R1 -|
      P -> Q -> |       |-> R1 /\ R2
                |-> R2 -|
      >>

      The chain <<P1 -> P2 -> Q>> has length 2 in [bar]:
      <<
                       |-> R1 -> T1 -|
      P1 -> P2 -> Q -> |             |-> U1 /\ U2
                       |-> R2 -> T2 -|
      >>
   *)

  Restart.

  intros P1 P2 Q R1 R2 T1 T2.
  intros H_P1 H_P1_implies_P2 H_P2_implies_Q H_Q_implies_R1 H_R1_implies_T1 H_Q_implies_R2 H_R2_implies_T2.

  (** Here, use the split tactic as late as possible.

      This requires us to construct two hypotheses of type [T1] and [T2], then do a [split], then apply those two constructed hypotheses in each of the cases.

      So we are forced to do a forward proof.
   *)
  assert (H_P2 := H_P1_implies_P2 H_P1).
  assert (H_Q := H_P2_implies_Q H_P2).
  assert (H_R1 := H_Q_implies_R1 H_Q).
  assert (H_R2 := H_Q_implies_R2 H_Q).
  assert (H_T1 := H_R1_implies_T1 H_R1).
  assert (H_T2 := H_R2_implies_T2 H_R2).
  split.
  - exact H_T1.
  - exact H_T2.
  Show Proof.
  (** The term corresponding to this proof is:
      <<
(fun (P1 P2 Q R1 R2 T1 T2 : Prop) (H_P1 : P1) (H_P1_implies_P2 : P1 -> P2) (H_P2_implies_Q : P2 -> Q)
   (H_Q_implies_R1 : Q -> R1) (H_R1_implies_T1 : R1 -> T1) (H_Q_implies_R2 : Q -> R2)
   (H_R2_implies_T2 : R2 -> T2) =>
 let H_P2 : P2 := H_P1_implies_P2 H_P1 in
 let H_Q : Q := H_P2_implies_Q H_P2 in
 let H_R1 : R1 := H_Q_implies_R1 H_Q in
 let H_R2 : R2 := H_Q_implies_R2 H_Q in
 let H_T1 : T1 := H_R1_implies_T1 H_R1 in let H_T2 : T2 := H_R2_implies_T2 H_R2 in conj H_T1 H_T2)
      >>

      Note the lack of repeated occurences of [H_P2_implies_Q (H_P1_implies_P2 H_P1)] - these have been replaced by [H_Q].
   *)

Qed.

(* ********** *)

(** * Exercise 11 *)

(* Prove baz:

   (1) by using the split tactic as early as possible 

   (2) by using the split tactic as late as possible 
*)

Proposition baz :
  forall P Q R T U1 U2 : Prop,
    P -> (P -> Q) -> (Q -> R) -> (R -> T) -> (T -> U1) -> (T -> U2) -> U1 /\ U2.
Proof.
  intros P Q R T U1 U2.
  intros H_P H_P_implies_Q H_Q_implies_R H_R_implies_T H_T_implies_U1 H_T_implies_U2.

  (** Here, use the split tactic as early as possible.

      Just like Exercise 10, we do a backward proof.
   *)

  split.
  - apply H_T_implies_U1.
    apply H_R_implies_T.
    apply H_Q_implies_R.
    apply H_P_implies_Q.
    exact H_P.
  - apply H_T_implies_U2.
    apply H_R_implies_T.
    apply H_Q_implies_R.
    apply H_P_implies_Q.
    exact H_P.
  Show Proof.
  (** The term corresponding to this proof is:
      <<
(fun (P Q R T U1 U2 : Prop) (H_P : P) (H_P_implies_Q : P -> Q) (H_Q_implies_R : Q -> R) 
   (H_R_implies_T : R -> T) (H_T_implies_U1 : T -> U1) (H_T_implies_U2 : T -> U2) =>
 conj (H_T_implies_U1 (H_R_implies_T (H_Q_implies_R (H_P_implies_Q H_P))))
   (H_T_implies_U2 (H_R_implies_T (H_Q_implies_R (H_P_implies_Q H_P)))))
      >>

      Note the repeated occurences of [(H_R_implies_T (H_Q_implies_R (H_P_implies_Q H_P)))].

      The three applications of hypotheses in these repeated occurences is, like explained in Exercise 10, due to the chain of implications until the point of divergence having length 3.
   *)

  Restart.

  intros P Q R T U1 U2.
  intros H_P H_P_implies_Q H_Q_implies_R H_R_implies_T H_T_implies_U1 H_T_implies_U2.

  (** Here, use the split tactic as late as possible.

      Here, we construct a forward proof like was already done in Exercise 10.
   *)

  assert (H_Q := H_P_implies_Q H_P).
  assert (H_R := H_Q_implies_R H_Q).
  assert (H_T := H_R_implies_T H_R).
  assert (H_U1 := H_T_implies_U1 H_T).
  assert (H_U2 := H_T_implies_U2 H_T).
  split.
  - exact H_U1.
  - exact H_U2.
  Show Proof.
  (** The term corresponding to this proof is:
      <<
(fun (P Q R T U1 U2 : Prop) (H_P : P) (H_P_implies_Q : P -> Q) (H_Q_implies_R : Q -> R) 
   (H_R_implies_T : R -> T) (H_T_implies_U1 : T -> U1) (H_T_implies_U2 : T -> U2) =>
 let H_Q : Q := H_P_implies_Q H_P in
 let H_R : R := H_Q_implies_R H_Q in
 let H_T : T := H_R_implies_T H_R in
 let H_U1 : U1 := H_T_implies_U1 H_T in let H_U2 : U2 := H_T_implies_U2 H_T in conj H_U1 H_U2)
      >>
      
      Note the lack of repeated occurences of [(H_R_implies_T (H_Q_implies_R (H_P_implies_Q H_P)))] - these have been replaced by [H_T].
   *)

Qed.

(* ********** *)

(** * Exercise 12 *)

(* Complete the proofs of baz_dual,
   and then compare them.
*)

Proposition baz_dual_early :
  forall P1 P2 Q R T U : Prop,
    (P1 \/ P2) -> (P1 -> Q) -> (P2 -> Q) -> (Q -> R) -> (R -> T) -> (T -> U) -> U.
Proof.
  intros P1 P2 Q R T U.
  intros H_P1_or_P2 H_P1_implies_Q H_P2_implies_Q H_Q_implies_R H_R_implies_T H_T_implies_U.

  (** ** a
      Use "destruct H_P1_or_P2 as [H_P1 | H_P2]." as early as you can.

      This is a forward proof, because we use a tactic on the initial hypothesis.
   *)

  destruct H_P1_or_P2 as [H_P1 | H_P2].

  - apply H_T_implies_U.
    apply H_R_implies_T.
    apply H_Q_implies_R.
    apply H_P1_implies_Q.
    exact H_P1.
  - apply H_T_implies_U.
    apply H_R_implies_T.
    apply H_Q_implies_R.
    apply H_P2_implies_Q.
    exact H_P2.
  Show Proof.
  (** The term corresponding to this proof is:
      <<
(fun (P1 P2 Q R T U : Prop) (H_P1_or_P2 : P1 \/ P2) (H_P1_implies_Q : P1 -> Q) (H_P2_implies_Q : P2 -> Q)
   (H_Q_implies_R : Q -> R) (H_R_implies_T : R -> T) (H_T_implies_U : T -> U) =>
 match H_P1_or_P2 with
 | or_introl H_P1 => H_T_implies_U (H_R_implies_T (H_Q_implies_R (H_P1_implies_Q H_P1)))
 | or_intror H_P2 => H_T_implies_U (H_R_implies_T (H_Q_implies_R (H_P2_implies_Q H_P2)))
 end)
      >>

      Note the repeated occurences of [H_T_implies_U (H_R_implies_T (H_Q_implies_R (H_P2_implies_Q H_P2)))].

      Compared to our use of [destruct] on a hypothesis that is a conjunction as early as possible in the alternative backward proof of Exercise 9, here the [destruct] is used on a hypothesis that is a disjunction.

      So, there are no discarded hypotheses: there are no underscores in the pattern match.
   *)

Qed.

Proposition baz_dual_late :
  forall P1 P2 Q R T U : Prop,
    (P1 \/ P2) -> (P1 -> Q) -> (P2 -> Q) -> (Q -> R) -> (R -> T) -> (T -> U) -> U.
Proof.
  intros P1 P2 Q R T U.
  intros H_P1_or_P2 H_P1_implies_Q H_P2_implies_Q H_Q_implies_R H_R_implies_T H_T_implies_U.

  (** ** b
      Use "destruct H_P1_or_P2 as [H_P1 | H_P2]." as late as you can.

      Because we cannot start by [destruct]ing the initial hypothesis (it is possible to delay the [destruct]), so a forward proof is impossible. So we do a backward proof.
   *)

  apply H_T_implies_U.
  apply H_R_implies_T.
  apply H_Q_implies_R.
  (** Here, we cannot [apply H_P1_implies_Q.], because if we do, then when we [destruct H_P1_or_P2], we generate two subgoals, each with goal [P1]. So we must prove [P1] twice. But the [destruct H_P1_or_P2 as [H_P1 | H_P2]] will generate [H_P1] in the first subgoal, and [H_P2] in the second subgoal. We can prove the first subgoal by [exact H_P1], but the second subgoal cannot be proven.

      A similar problem arises if we [apply H_P2_implies_Q.].
   *)
  apply H_P1_implies_Q.
  destruct H_P1_or_P2 as [H_P1 | H_P2].
  - exact H_P1.
  - (* stuck *)

  Restart.

  intros P1 P2 Q R T U.
  intros H_P1_or_P2 H_P1_implies_Q H_P2_implies_Q H_Q_implies_R H_R_implies_T H_T_implies_U.
  apply H_T_implies_U.
  apply H_R_implies_T.
  apply H_Q_implies_R.
  (** The way to prove this is to "duplicate" the proof goal [Q] across the two subgoals generated by the [destruct] on a hypothesis that is a disjunction, by delaying the [apply] till within each of the subgoals. So here we are forced to use [destruct], and this is as late in the proof as we can use [destruct].

      Note that unlike the [destruct] on a conjunction in Exercise 9, here there are no discarded hypotheses, because we do a [destruct] on a disjunction.
   *)

  destruct H_P1_or_P2 as [H_P1 | H_P2].
  - apply H_P1_implies_Q.
    exact H_P1.
  - apply H_P2_implies_Q.
    exact H_P2.
  Show Proof.
  (** The term corresponding to this proof is:
      <<
(fun (P1 P2 Q R T U : Prop) (H_P1_or_P2 : P1 \/ P2) (H_P1_implies_Q : P1 -> Q) (H_P2_implies_Q : P2 -> Q)
   (H_Q_implies_R : Q -> R) (H_R_implies_T : R -> T) (H_T_implies_U : T -> U) =>
 H_T_implies_U
   (H_R_implies_T
      (H_Q_implies_R
         match H_P1_or_P2 with
         | or_introl H_P1 => H_P1_implies_Q H_P1
         | or_intror H_P2 => H_P2_implies_Q H_P2
         end)))
      >>

      Note the lack of repeated occurences of [H_T_implies_U (H_R_implies_T (H_Q_implies_R (H_P2_implies_Q H_P2)))]. Unlike the lack of repeated occurences in previous Exercises, here the lack is not due to a <<let>>-<<in>> binding (in this case, it would have been a [H_T]), because here we do a backward proof. Instead, the goal is transformed such that a [H_T] is no longer needed. Indeed, the goal is transformed into something similar to the or-introduction rule from logic: <<(P1 \/ P2) -> (P1 -> Q) -> (P2 -> Q) -> Q.>>
   *)

Qed.

(** ** c TODO
    The two proofs Exercise 12a and Exercise 12b have already been compared.
 *)

(** ** d
    Complete the following proof.
    What do you end up with?
    A proof close to that of Proposition baz_dual_early,
    or to that of Proposition baz_dual_late?
    What do you conclude?
 *)

Proposition baz_dual_early_or_late :
  forall P1 P2 Q R T U : Prop,
    (P1 \/ P2) -> (P1 -> Q) -> (P2 -> Q) -> (Q -> R) -> (R -> T) -> (T -> U) -> U.
Proof.
  intros P1 P2 Q R T U.
  intros [H_P1 | H_P2] H_P1_implies_Q H_P2_implies_Q H_Q_implies_R H_R_implies_T H_T_implies_U.

  (** The [destruct] tactic was already implicitly used in [intros [H_P1 | H_P2]]. Therefore this is the use of [destruct] as early as possible, and the following proof corresponds to Exercise 12a.
   *)

  - apply H_T_implies_U.
    apply H_R_implies_T.
    apply H_Q_implies_R.
    apply H_P1_implies_Q.
    exact H_P1.
  - apply H_T_implies_U.
    apply H_R_implies_T.
    apply H_Q_implies_R.
    apply H_P2_implies_Q.
    exact H_P2.
  Show Proof.
  (** The term corresponding to this proof is:
      <<
(fun (P1 P2 Q R T U : Prop) (H : P1 \/ P2) =>
 match H with
 | or_introl H_P1 =>
     fun (H_P1_implies_Q : P1 -> Q) (_ : P2 -> Q) (H_Q_implies_R : Q -> R) (H_R_implies_T : R -> T)
       (H_T_implies_U : T -> U) => H_T_implies_U (H_R_implies_T (H_Q_implies_R (H_P1_implies_Q H_P1)))
 | or_intror H_P2 =>
     fun (_ : P1 -> Q) (H_P2_implies_Q : P2 -> Q) (H_Q_implies_R : Q -> R) (H_R_implies_T : R -> T)
       (H_T_implies_U : T -> U) => H_T_implies_U (H_R_implies_T (H_Q_implies_R (H_P2_implies_Q H_P2)))
 end)
      >>

      Compared to the term corresponding to the proof of Exercise 12a, there are discarded hypotheses: there are underscores in the function parameters. This is because when we construct functions within a case-split, not all of the parameters (hypotheses) are needed in each subgoal.

      On the other hand, the proof of Exercise 12a has the case-split within the body of the function, and both hypotheses are used: one hypothesis is used in one case, and the other hypothesis is used in the other case. So, there is no discarding of hypotheses there.

      The conclusion from Exercise 12d is: there is a substantial difference in whether hypotheses are discarded, depending on whether [intros] is done before [destruct], or the [destruct] is done before [intros]. Practically, less underscores in the parameters means better readability of proofs.
   *)

Qed.

(* ********** *)

(** * Exercise 13 *)

(** How would you prove the following propositions?
    Forward or backward?

    [ladidah] has an initial hypothesis that is a disjunction, just like Exercise 12a and Exercise 12b. The term corresponding to the forward proof of Exercise 12a has repeated applications while the backward proof of Exercise 12b does not, so to avoid repeated applications, we prove [ladidah] in a backward way.

    This means using [destruct] as late as possible.
 *)

Proposition ladidah :
  forall P1 P2 P3 P4 Q R T U : Prop,
    (P1 \/ P2) \/ (P3 \/ P4) -> (P1 -> Q) -> (P2 -> Q) -> (P3 -> Q) -> (P4 -> Q) -> (Q -> R) -> (R -> T) -> (T -> U) -> U.
Proof.
  intros P1 P2 P3 P4 Q R T U.
  intros H_P1_or_P2_or_P3_or_P4 H_P1_implies_Q H_P2_implies_Q H_P3_implies_Q H_P4_implies_Q H_Q_implies_R H_R_implies_T H_T_implies_U.
  apply H_T_implies_U.
  apply H_R_implies_T.
  apply H_Q_implies_R.
  (** Here our goal is the proposition [Q] which is the consequent of the implications of which the antecedents are each of the four disjuncts in the initial hypothesis.

      As noted in Exercise 12b, we must [destruct] here.
   *)

  destruct H_P1_or_P2_or_P3_or_P4 as [[H_P1 | H_P2] | [H_P3 | H_P4]].
  - apply (H_P1_implies_Q H_P1).
  - apply (H_P2_implies_Q H_P2).
  - apply (H_P3_implies_Q H_P3).
  - apply (H_P4_implies_Q H_P4).
  Show Proof.
  (** The term corresponding to this proof is:
      <<
(fun (P1 P2 P3 P4 Q R T U : Prop)
   (H_P1_or_P2_or_P3_or_P4 : (P1 \/ P2) \/ P3 \/ P4)
   (H_P1_implies_Q : P1 -> Q) (H_P2_implies_Q : P2 -> Q)
   (H_P3_implies_Q : P3 -> Q) (H_P4_implies_Q : P4 -> Q)
   (H_Q_implies_R : Q -> R) (H_R_implies_T : R -> T)
   (H_T_implies_U : T -> U) =>
 H_T_implies_U
   (H_R_implies_T
      (H_Q_implies_R
         match H_P1_or_P2_or_P3_or_P4 with
         | or_introl (or_introl H_P1) => H_P1_implies_Q H_P1
         | or_introl (or_intror H_P2) => H_P2_implies_Q H_P2
         | or_intror (or_introl H_P3) => H_P3_implies_Q H_P3
         | or_intror (or_intror H_P4) => H_P4_implies_Q H_P4
         end)))
      >>
   *)

Qed.

(** How would you prove the following propositions?
    Forward or backward?

    [toodeloo] has a conclusion that is a conjunction, just like Exercise 9, Exercise 10, and Exercise 11. In each of these exercises, the backward proof has repeated applications while the forward proof does not, so to avoid repeated applications, we prove [toodeloo] in a forward way.

    This means using [split] as late as possible.
 *)

Proposition toodeloo :
  forall P Q R T U1 U2 U3 U4: Prop,
    P -> (P -> Q) -> (Q -> R) -> (R -> T) -> (T -> U1) -> (T -> U2) -> (T -> U3) -> (T -> U4) -> (U1 /\ U2) /\ (U3 /\ U4).
  intros P Q R T U1 U2 U3 U4.
  intros H_P H_P_implies_Q H_Q_implies_R H_R_implies_T H_T_implies_U1 H_T_implies_U2 H_T_implies_U3 H_T_implies_U4.
  assert (H_Q := H_P_implies_Q H_P).
  assert (H_R := H_Q_implies_R H_Q).
  assert (H_T := H_R_implies_T H_R).
  assert (H_U1 := H_T_implies_U1 H_T).
  assert (H_U2 := H_T_implies_U2 H_T).
  assert (H_U3 := H_T_implies_U3 H_T).
  assert (H_U4 := H_T_implies_U4 H_T).
  
  (** The latest possible [split] is immediately after we have the four conjuncts. *)
  split.
  - split.
    + exact H_U1.
    + exact H_U2.
  - split.
    + exact H_U3.
    + exact H_U4.
Qed.

(** How complex could the size of such proofs be
    (relative to the number of hypotheses about P1, P2, P3, etc.
    and to the number of conclusions about U1, U2, U3, etc.)?

    We have delayed as late as possible the proof of the disjunctive hypothesis, so that [destruct]ing the disjunctive hypothesis only requires us to, for each subgoal, apply one hypothesis to another. So, the complexity of the size of the proof relative to the number of hypotheses about [P1], [P2], [P3], [P4], is the complexity of the size of the remaining proof, which has linear complexity.

    We have delayed as late as possible the proof of the conjunctive hypothesis, so that [split]ting the conjunctive hypothesis only requires us to, for each subgoal, say that the subgoal exactly matches one hypothesis. So, the complexity of the size of the proof relative to the number of hypotheses about [U1], [U2], [U3], [U4], is the complexity of the size of the remaining proof, which has linear complexity.
 *)

(* ***********)

(* end of week-04_backward-and-forward-proofs.v *)

(* week-04_equational-reasoning-about-arithmetical-functions.v *)
(* FPP 2020 - YSC3236 2020-2011, Sem1 *)
(* Olivier Danvy <danvy@yale-nus.edu.sg> *)
(* Version of 05 Sep 2020 *)

(* ********** *)

(* Your name: Koo Zhengqun
   Your e-mail address: zhengqun.koo@u.nus.edu
   Your student number: A0164207L
 *)

(* Your name: Bobbie Soedirgo
   Your e-mail address: sram-b@comp.nus.edu.sg
   Your student number: A0181001A
 *)

(* Your name: Kuan Wei Heng
   Your e-mail address: kuanwh@u.nus.edu
   Your student number: A0121712X
 *)

(* ********** *)

(** begin hide **)

(* Paraphernalia: *)

Ltac fold_unfold_tactic name := intros; unfold name; fold name; reflexivity.

Require Import Arith Bool.

Notation "A =n= B" :=
  (beq_nat A B) (at level 70, right associativity).

(* ********** *)

(* Two implementations of the addition function *)

(* ***** *)

(* Unit tests *)

Definition test_add (candidate: nat -> nat -> nat) : bool :=
  (candidate 0 0 =n= 0)
  &&
  (candidate 0 1 =n= 1)
  &&
  (candidate 1 0 =n= 1)
  &&
  (candidate 1 1 =n= 2)
  &&
  (candidate 1 2 =n= 3)
  &&
  (candidate 2 1 =n= 3)
  &&
  (candidate 2 2 =n= 4)
  (* etc. *)
  .

(* ***** *)

(* Recursive implementation of the addition function *)

Fixpoint add_v1 (i j : nat) : nat :=
  match i with
  | O =>
    j
  | S i' =>
    S (add_v1 i' j)
  end.

Compute (test_add add_v1).

Lemma fold_unfold_add_v1_O :
  forall j : nat,
    add_v1 O j =
    j.
Proof.
  fold_unfold_tactic add_v1.
Qed.

Lemma fold_unfold_add_v1_S :
  forall i' j : nat,
    add_v1 (S i') j =
    S (add_v1 i' j).
Proof.
  fold_unfold_tactic add_v1.
Qed.

(* ***** *)

(* Tail-recursive implementation of the addition function *)

Fixpoint add_v2 (i j : nat) : nat :=
  match i with
    | O => j
    | S i' => add_v2 i' (S j)
  end.

Compute (test_add add_v2).

Lemma fold_unfold_add_v2_O :
  forall j : nat,
    add_v2 O j =
    j.
Proof.
  fold_unfold_tactic add_v2.
Qed.

Lemma fold_unfold_add_v2_S :
  forall i' j : nat,
    add_v2 (S i') j =
    add_v2 i' (S j).
Proof.
  fold_unfold_tactic add_v2.
Qed.

(* ********** *)

(* Equivalence of add_v1 and add_v2 *)

(* ***** *)

(* The master lemma: *)

Lemma about_add_v2 :
  forall i j : nat,
    add_v2 i (S j) = S (add_v2 i j).
Proof.
  intro i.
  induction i as [ | i' IHi'].

  - intro j.
    rewrite -> (fold_unfold_add_v2_O j).
    exact (fold_unfold_add_v2_O (S j)).

  - intro j.
    rewrite -> (fold_unfold_add_v2_S i' (S j)).
    rewrite -> (fold_unfold_add_v2_S i' j).
    Check (IHi' (S j)).
    exact (IHi' (S j)).
Qed.

(* ***** *)

(* The main theorem: *)

Theorem equivalence_of_add_v1_and_add_v2 :
  forall i j : nat,
    add_v1 i j = add_v2 i j.
Proof.
  intro i.
  induction i as [ | i' IHi'].

  - intro j.
    rewrite -> (fold_unfold_add_v2_O j).
    exact (fold_unfold_add_v1_O j).

  - intro j.
    rewrite -> (fold_unfold_add_v1_S i' j).
    rewrite -> (fold_unfold_add_v2_S i' j).
    rewrite -> (IHi' j).
    symmetry.
    exact (about_add_v2 i' j).
Qed.

(* In the next few exercises, we prove some basic properties of addition.
 Having established the equivalence of both implementations of addition, proving
 a property for either automatically gives us a proof for the other. This has
 the advantage of making the proofs easier since we have the flexibility to pick
 the implementation that best lends itself to proving the property in question.
 Nonetheless, we will respect the learning objective of these exercises prove
 the properties for both implementations without invoking the equivalence. *)

(* ********** *)

(* Neutral (identity) element for addition *)

(* ***** *)

Property O_is_left_neutral_wrt_add_v1 :
  forall y : nat,
    add_v1 0 y = y.
Proof.
  exact fold_unfold_add_v1_O.
Qed.

(* ***** *)

Property O_is_left_neutral_wrt_add_v2 :
  forall y : nat,
    add_v2 0 y = y.
Proof.
  exact fold_unfold_add_v2_O.
Qed.

(* ***** *)

Property O_is_right_neutral_wrt_add_v1 :
  forall x : nat,
    add_v1 x 0 = x.
Proof.
  induction x as [| x' IHx'].
  - exact (fold_unfold_add_v1_O 0).
  - unfold add_v1. fold add_v1.
    rewrite -> IHx'.
    reflexivity.
Qed.

(* The 'master lemma' proven earlier turns out to be very useful in our proofs.
When proving the inductive case, we always start with an extra successor call on
both sides of the subgoal. In order to apply the inductive hypothesis, we have
to move the successor call to the top level of the expression tree. This lemma
lets us do that. *)

(* We will give it a more meaningful name. *)
Notation add_succ_r_v2 := about_add_v2.

(* We will also prove an equivalent for [add_v1]. *)
Lemma add_succ_r_v1 :
  forall i j : nat,
    add_v1 i (S j) = S (add_v1 i j).
Proof.
  induction  i as [| i' IHi'].
  - intro j.
    rewrite -> (fold_unfold_add_v1_O j).
    exact (fold_unfold_add_v1_O (S j)).
  - intro j.
    rewrite -> (fold_unfold_add_v1_S i' (S j)).
    rewrite -> (fold_unfold_add_v1_S i' j).
    rewrite -> (IHi' j).
    reflexivity.
Qed.

Property O_is_right_neutral_wrt_add_v2 :
  forall x : nat,
    add_v2 x 0 = x.
Proof.
  induction x as [| x' IHx'].
  - exact (fold_unfold_add_v2_O 0).
  - unfold add_v2. fold add_v2.
    rewrite <- IHx' at 2.
    exact (add_succ_r_v2 x' 0).
Qed.

(* ********** *)

(* Associativity of addition *)

(* ***** *)

Property add_v1_is_associative :
  forall x y z : nat,
    add_v1 x (add_v1 y z) = add_v1 (add_v1 x y) z.
Proof.
  induction x as [| x' IHx'].
  - fold_unfold_tactic add_v1.
  - intros y z.
    unfold add_v1. fold add_v1.
    rewrite <- (IHx' y z).
    reflexivity.
Qed.

(* ***** *)

Property add_v2_is_associative :
  forall x y z : nat,
    add_v2 x (add_v2 y z) = add_v2 (add_v2 x y) z.
Proof.
  induction x as [| x' IHx'].
  - fold_unfold_tactic add_v2.
  - intros y z.
    unfold add_v2. fold add_v2.
    rewrite -> (add_succ_r_v2 x' (add_v2 y z)).
    rewrite (IHx' y z).
    rewrite -> (add_succ_r_v2 x' y).
    unfold add_v2. fold add_v2.
    rewrite -> (add_succ_r_v2 (add_v2 x' y) z).
    reflexivity.
Qed.

(* ********** *)

(* Commutativity of addition *)

(* ***** *)

Property add_v1_is_commutative :
  forall x y : nat,
    add_v1 x y = add_v1 y x.
Proof.
  induction x as [| x' IHx'].
  - intro y.
    rewrite -> (O_is_right_neutral_wrt_add_v1 y).
    rewrite -> (O_is_left_neutral_wrt_add_v1 y).
    reflexivity.
  - intro y.
    rewrite -> (fold_unfold_add_v1_S x' y).
    rewrite -> (IHx' y).
    symmetry.
    exact (add_succ_r_v1 y x').
Qed.

(* ***** *)

Property add_v2_is_commutative :
  forall x y : nat,
    add_v2 x y = add_v2 y x.
Proof.
  induction x as [| x' IHx'].
  - intro y.
    rewrite -> (O_is_right_neutral_wrt_add_v2 y).
    rewrite -> (O_is_left_neutral_wrt_add_v2 y).
    reflexivity.
  - intro y.
    rewrite -> (fold_unfold_add_v2_S x' y).
    rewrite -> (add_succ_r_v2 x' y).
    rewrite -> (add_succ_r_v2 y x').
    rewrite -> (IHx' y).
    reflexivity.
Qed.

(* ********** *)

(* Four implementations of the multiplication function *)

(* ***** *)

(* Unit tests *)

Definition test_mul (candidate: nat -> nat -> nat) : bool :=
  (candidate 0 0 =n= 0)
  &&
  (candidate 0 1 =n= 0)
  &&
  (candidate 1 0 =n= 0)
  &&
  (candidate 1 1 =n= 1)
  &&
  (candidate 1 2 =n= 2)
  &&
  (candidate 2 1 =n= 2)
  &&
  (candidate 2 2 =n= 4)
  &&
  (candidate 2 3 =n= 6)
  &&
  (candidate 3 2 =n= 6)
  &&
  (candidate 6 4 =n= 24)
  &&
  (candidate 4 6 =n= 24)
  (* etc. *)
  .

(* ***** *)

(* Recursive implementation of the multiplication function, using add_v1 *)

Fixpoint mul_v11 (x y : nat) : nat :=
  match x with
  | O =>
    O
  | S x' =>
    add_v1 (mul_v11 x' y) y
  end.

Compute (test_mul mul_v11).

Lemma fold_unfold_mul_v11_O :
  forall y : nat,
    mul_v11 O y =
    O.
Proof.
  fold_unfold_tactic mul_v11.
Qed.

Lemma fold_unfold_mul_v11_S :
  forall x' y : nat,
    mul_v11 (S x') y =
    add_v1 (mul_v11 x' y) y.
Proof.
  fold_unfold_tactic mul_v11.
Qed.

(* ***** *)

(* Recursive implementation of the multiplication function, using add_v2 *)

Fixpoint mul_v12 (x y : nat) : nat :=
  match x with
  | O =>
    O
  | S x' =>
    add_v2 (mul_v12 x' y) y
  end.

Compute (test_mul mul_v11).

Lemma fold_unfold_mul_v12_O :
  forall y : nat,
    mul_v12 O y =
    O.
Proof.
  fold_unfold_tactic mul_v12.
Qed.

Lemma fold_unfold_mul_v12_S :
  forall x' y : nat,
    mul_v12 (S x') y =
    add_v2 (mul_v12 x' y) y.
Proof.
  fold_unfold_tactic mul_v12.
Qed.

(** end hide **)

(* ***** *)

(** ** Exercise 27 *)

(* Tail-recursive implementation of the multiplication function, using add_v1 *)

Fixpoint mul_v21_aux (x y a : nat) : nat :=
  match x with
  | O => a
  | S x' => mul_v21_aux x' y (add_v1 y a)
  end.

Definition mul_v21 (x y : nat) : nat :=
  mul_v21_aux x y 0.

Compute (test_mul mul_v21).

Lemma fold_unfold_mul_v21_aux_O :
  forall y a : nat , mul_v21_aux 0 y a = a.
Proof.
  fold_unfold_tactic mul_v21_aux.
Qed.

Lemma fold_unfold_mul_v21_aux_S :
  forall x' y a : nat, mul_v21_aux (S x') y a = mul_v21_aux x' y (add_v1 y a).
Proof.
  fold_unfold_tactic mul_v21_aux.
Qed.

(* ***** *)

(** ** Exercise 28 *)

(* Tail-recursive implementation of the multiplication function, using add_v2 *)

Fixpoint mul_v22_aux (x y a : nat) : nat :=
  match x with
  | O => a
  | S x' => mul_v22_aux x' y (add_v2 y a)
  end.

Definition mul_v22 (x y : nat) : nat :=
  mul_v22_aux x y 0.

Lemma fold_unfold_mul_v22_aux_O :
  forall y a : nat, mul_v22_aux 0 y a = a.
Proof.
  fold_unfold_tactic mul_v22_aux.
Qed.

Lemma fold_unfold_mul_v22_aux_S :
  forall x' y a : nat, mul_v22_aux (S x') y a = mul_v22_aux x' y (add_v2 y a).
Proof.
  fold_unfold_tactic mul_v22_aux.
Qed.

(* ********** *)

(** ** Exercise 29 *)

(* Equivalence of mul_v11, mul_v12, mul_v21, and mul_v22 *)

(* ***** *)

Theorem equivalence_of_mul_v11_and_mul_v12 :
  forall i j : nat,
    mul_v11 i j = mul_v12 i j.
Proof.
  induction i as [| i' IHi'].
  - intro j.
    rewrite -> (fold_unfold_mul_v11_O j).
    exact (fold_unfold_mul_v12_O j).
  - intro j.
    rewrite -> (fold_unfold_mul_v11_S i' j).
    rewrite -> (fold_unfold_mul_v12_S i' j).
    rewrite -> (IHi' j).
    exact (equivalence_of_add_v1_and_add_v2 (mul_v12 i' j) j).
Qed.

(* ***** *)

(* The proof for the equivalence of [mul_v11] and [mul_v21] requires the
following lemma, which lets us decompose the accumulator of [mul_v21_aux] as a
sum of two naturals and have the sum evaluate after the product. *)

Lemma mul_v21_aux_accumulator_distributes :
  forall i j a b : nat, add_v1 (mul_v21_aux i j a) b = mul_v21_aux i j (add_v1 a b).
Proof.
  induction i as [| i' IHi'].
  - intros j a b.
    rewrite -> (fold_unfold_mul_v21_aux_O j a).
    rewrite -> (fold_unfold_mul_v21_aux_O j (add_v1 a b)).
    reflexivity.
  - intros j a b.
    rewrite -> (fold_unfold_mul_v21_aux_S i' j a).
    rewrite -> (fold_unfold_mul_v21_aux_S i' j (add_v1 a b)).
    rewrite <- (IHi' j j a).
    rewrite <- (IHi' j j (add_v1 a b)).
    rewrite -> (add_v1_is_associative (mul_v21_aux i' j j) a b).
    reflexivity.
Qed.

Theorem equivalence_of_mul_v11_and_mul_v21 :
  forall i j : nat,
    mul_v11 i j = mul_v21 i j.
Proof.
  unfold mul_v21.
  induction i as [| i' IHi'].
  - intro j.
    rewrite -> (fold_unfold_mul_v11_O j).
    exact (fold_unfold_mul_v21_aux_O j 0).
  - intro j.
    rewrite -> (fold_unfold_mul_v11_S i' j).
    Check fold_unfold_mul_v21_aux_S.
    rewrite -> (fold_unfold_mul_v21_aux_S i' j).
    rewrite -> (IHi' j).
    rewrite -> (add_v1_is_commutative j 0).
    exact (mul_v21_aux_accumulator_distributes i' j 0 j).
Qed.

(* ***** *)

(* The previous proof can also be directly translated to a proof for the
equivalence of [mul_v12] and [mul_v22] since these two pairs of implementations
are only different in the implementation of addition used. *)

Lemma mul_v22_aux_accumulator_distributes :
  forall i j a b : nat, add_v2 (mul_v22_aux i j a) b = mul_v22_aux i j (add_v2 a b).
Proof.
  induction i as [| i' IHi'].
  - intros j a b.
    rewrite -> (fold_unfold_mul_v22_aux_O j a).
    rewrite -> (fold_unfold_mul_v22_aux_O j (add_v2 a b)).
    reflexivity.
  - intros j a b.
    rewrite -> (fold_unfold_mul_v22_aux_S i' j a).
    rewrite -> (fold_unfold_mul_v22_aux_S i' j (add_v2 a b)).
    rewrite <- (IHi' j j a).
    rewrite <- (IHi' j j (add_v2 a b)).
    rewrite -> (add_v2_is_associative (mul_v22_aux i' j j) a b).
    reflexivity.
Qed.

Theorem equivalence_of_mul_v12_and_mul_v22 :
  forall i j : nat,
    mul_v12 i j = mul_v22 i j.
Proof.
  unfold mul_v22.
  induction i as [| i' IHi'].
  - intro j.
    rewrite -> (fold_unfold_mul_v12_O j).
    exact (fold_unfold_mul_v22_aux_O j 0).
  - intro j.
    rewrite -> (fold_unfold_mul_v12_S i' j).
    Check fold_unfold_mul_v22_aux_S.
    rewrite -> (fold_unfold_mul_v22_aux_S i' j).
    rewrite -> (IHi' j).
    rewrite -> (add_v2_is_commutative j 0).
    exact (mul_v22_aux_accumulator_distributes i' j 0 j).
Qed.

(* ***** *)

(* The previous three proofs are sufficient to demonstrate the equivalence of
all four implementations. For completeness, we will also prove the equivalence
of [mul_v21] and [mul_v22]. *)

Theorem equivalence_of_mul_v21_and_mul_v22 :
  forall i j : nat,
    mul_v21 i j = mul_v22 i j.
Proof.
  unfold mul_v21.
  unfold mul_v22.
  induction i as [| i' IHi'].
  - intro j.
    rewrite -> (fold_unfold_mul_v21_aux_O j 0).
    exact (fold_unfold_mul_v22_aux_O j 0).
  - intro j.
    Check fold_unfold_mul_v21_aux_S.
    rewrite -> (fold_unfold_mul_v21_aux_S i' j).
    rewrite -> (fold_unfold_mul_v22_aux_S i' j).
    rewrite -> (add_v1_is_commutative j 0).
    rewrite -> (add_v2_is_commutative j 0).
    Check (mul_v22_aux_accumulator_distributes).
    rewrite <- (mul_v21_aux_accumulator_distributes i' j 0 j).
    rewrite <- (mul_v22_aux_accumulator_distributes i' j 0 j).
    rewrite -> (IHi' j).
    exact (equivalence_of_add_v1_and_add_v2 (mul_v22_aux i' j 0) j).
Qed.

(** begin hide **)

(* ********** *)

(* 0 is left absorbing with respect to multiplication *)

(* ***** *)

Property O_is_left_absorbing_wrt_mul_v11 :
  forall y : nat,
    mul_v11 0 y = 0.
Proof.
Abort.

(* ***** *)

Property O_is_left_absorbing_wrt_mul_v12 :
  forall y : nat,
    mul_v12 0 y = 0.
Proof.
Abort.

(* ***** *)

(*
Property O_is_left_absorbing_wrt_mul_v21 :
  forall y : nat,
    mul_v21 0 y = 0.
Proof.
Abort.
*)

(* ***** *)

(*
Property O_is_left_absorbing_wrt_mul_v22 :
  forall y : nat,
    mul_v22 0 y = 0.
Proof.
Abort.
*)

(* ********** *)

(* 1 is left neutral with respect to multiplication *)

(* ***** *)

Property SO_is_left_neutral_wrt_mul_v11 :
  forall y : nat,
    mul_v11 1 y = y.
Proof.
Abort.

(* ***** *)

Property SO_is_left_neutral_wrt_mul_v12 :
  forall y : nat,
    mul_v12 1 y = y.
Proof.
Abort.

(* ***** *)

(*
Property SO_is_left_neutral_wrt_mul_v21 :
  forall y : nat,
    mul_v21 1 y = y.
Proof.
Abort.
*)

(* ***** *)

(*
Property SO_is_left_neutral_wrt_mul_v22 :
  forall y : nat,
    mul_v22 1 y = y.
Proof.
Abort.
*)

(* ********** *)

(* 0 is right absorbing with respect to multiplication *)

(* ***** *)

Property O_is_right_absorbing_wrt_mul_v11 :
  forall x : nat,
    mul_v11 x 0 = 0.
Proof.
Abort.

(* ***** *)

Property O_is_right_absorbing_wrt_mul_v12 :
  forall x : nat,
    mul_v12 x 0 = 0.
Proof.
Abort.

(* ***** *)

(*
Property O_is_right_absorbing_wrt_mul_v21 :
  forall x : nat,
    mul_v21 x 0 = 0.
Proof.
Abort.
*)

(* ***** *)

(*
Property O_is_right_absorbing_wrt_mul_v22 :
  forall x : nat,
    mul_v22 x 0 = 0.
Proof.
Abort.
*)

(* ********** *)

(* 1 is right neutral with respect to multiplication *)

(* ***** *)

Property SO_is_right_neutral_wrt_mul_v11 :
  forall x : nat,
    mul_v11 x 1 = x.
Proof.
Abort.

(* ***** *)

Property SO_is_right_neutral_wrt_mul_v12 :
  forall x : nat,
    mul_v12 x 1 = x.
Proof.
Abort.

(* ***** *)

(*
Property SO_is_right_neutral_wrt_mul_v21 :
  forall x : nat,
    mul_v21 x 1 = x.
Proof.
Abort.
*)

(* ***** *)

(*
Property SO_is_right_neutral_wrt_mul_v22 :
  forall x : nat,
    mul_v22 x 1 = x.
Proof.
Abort.
*)

(* ********** *)

(* Multiplication is right-distributive over addition *)

(* ***** *)

(* ... *)

(* ********** *)

(* Multiplication is associative *)

(* ***** *)

Property mul_v11_is_associative :
  forall x y z : nat,
    mul_v11 x (mul_v11 y z) = mul_v11 (mul_v11 x y) z.
Proof.
Abort.

(* ***** *)

Property mul_v12_is_associative :
  forall x y z : nat,
    mul_v12 x (mul_v12 y z) = mul_v12 (mul_v12 x y) z.
Proof.
Abort.

(* ***** *)

(*
Property mul_v21_is_associative :
  forall x y z : nat,
    mul_v21 x (mul_v21 y z) = mul_v21 (mul_v21 x y) z.
Proof.
Abort.
*)

(* ***** *)

(*
Property mul_v22_is_associative :
  forall x y z : nat,
    mul_v22 x (mul_v22 y z) = mul_v22 (mul_v22 x y) z.
Proof.
Abort.
*)

(* ********** *)

(* Multiplication is left-distributive over addition *)

(* ***** *)

(* ... *)

(* ********** *)

(** end hide **)

(* end of week-04_equational-reasoning-about-arithmetical-functions.v *)
